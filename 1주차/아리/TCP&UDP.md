# TCP & UDP 

## IP의 한계

- IP의 역할은 host간의 연결이다 .이때 장치에서 장치로의 이동은 해결되지만 하나의 장비 안에서 수많은 프로그램들이 통신하는 경우에는 한계가 있다. 이를 해결하기 위해 `포트번호`가 등장!
- IP의 오류는 ICMP가 알려준다. 하지만 알려주기만 할 뿐 대처를 못한다. 이를 해결하기 위해 `TCP`와 `UDP`가 등장!
    - TCP → 송수신 데이터의 정확한 전달 보장
    - UDP → 빠른 데이터 전송 보장
    - ICMP란? Internet Message Control Protocol로써 운영체제의 오류메시지를 전송하는 역할

## TCP

- 4계층(전송계층)에서 이용되며, 가장 큰 특징은 신뢰성을 보장한다는 것이다!
- 세션을 안전하게 연결하고, 데이터를 분할하고, 분할된 패킷이 잘 전송되었는지 확인하는 역할을 한다.
- 어떤 패킷이 새로운 연결시도이고, 어떤 패킷이 기존 통신인지 등을 구별하기 위해 헤더에 Flag라는 값을 담는다
    - SYN : 연결 시작
    - ACK : ACK 번호의 유효성 ( 유효할 경우 1 )
    - FIN :  정상적인 양방향 연결 종료
    - RST : 연결 강제종료
    - URG : 긴급 데이터
    - PSH : 서버측에서 전송할 데이터 없음 or 데이터를 응용 프로그램으로 즉시 전달해야함
- 패킷에 고유 번호를 나타내는 시퀀스 번호(SYN)와 응답 번호(ACK)를 부여한다.

## TCP 3 way handshake : 연결 성립

- 신뢰성을 보장하기 위해 통신 시작 전 3 way handshake 방식을 이용하여 사전 연결 작업을 진행한다.
- 목적지가 데이터를 받을 준비가 되어있지 않다면 데이터가 버려질 가능성이 크므로 안전하게 보내고 받을 수 있는지 확인하는 것!
- 3번의 패킷을 주고받으므로 3 way handshake라고 한다.
- 동작방식
    1. 클라이언트 → 서버 : 연결 시작
        1. 헤더의 SYN를 1로 표시 → 연결시작임을 알림
        2. SYN x → 자신이 사용할 첫 시퀀스 번호
    2. 서버 → 클라이언트 : 연결 허락
        1. 헤더의 SYN, ACK를 1로 표시
            1. 자신이 보내는 첫 패킷이므로 SYN 1
            2. 클라이언트가 보냈던 패킷의 응답이기도 하므로 ACK 1
        2. SYN y → 자신이 사용할 첫 시퀀스 번호
        3. ACK x+1 → 클라이언트가 보낸 x번 패킷에 대한 응답이라는 의미
    3. 클라이언트 → 서버 : 연결 확립
        1. 헤더의 ACK를 1로 표시 → 여기부터는 기존 메시지에 대한 응답이므로 SYN는 표시하지 않는다.
        2. SYN x+1 → x번 바로 다음에 보내는 패킷이므로 x+1
        3. ACK y+1 → 서버가 보낸 y번 패킷에 대한 응답이라는 의미
- x번을 잘 받았다는 의미인데 왜 x+1번 ACK를 보내는걸까?
  → x번 잘 받았으니 이제 x+1번 주면 된다~ 라고 알려주는 것!

## TCP  4 way handshake : 연결 해제

- 통신이 끝났음을 4 way handshake 방식을 이용하여 알린다.
- 4번의 패킷을 주고받으므로 4 way handshake라고 한다.
- 동작방식
    1. 클라이언트 → 서버
       : 연결을 종료한다는 의미로 헤더의 FIN 플래그를 보낸다
    2. 서버 → 클라이언트
       : 확인했다는 의미로 ACK를 보내고, 모든 데이터를 보내기 위해 CLOSE_WAIT 상태가 된다.
    3. 서버 → 클라이언트
       : 데이터를 모두 보냈다면 헤더의 FIN 플래그를 보낸다
    4. 클라이언트 → 서버
       : 확인했다는 의미로 ACK를 보내고 아직 받지 못한 데이터가 있을수도 있으므로 TIME_WAIT 상태가 되어 기다린다.
    5. 서버
       : 모든 데이터를 다 보냈고, 클라이언트에게 ACK도 받았으니 소켓을 닫아 CLOSED 상태가 된다.
    6. 클라이언트
       : TIME_WAIT 시간이 끝나면 소켓을 닫아 CLOSED 상태가 된다.

## 흐름제어

: `송신측과 수신측의 데이터 처리 속도 차이`를 해결하기 위한 기법
: 수신측이 패킷을 지나치게 많지 받지 않도록 조절하기 위해 `수신측이 송신측에게 자신의 상태를 알려주는 것!`

- Stop And Wait
    - 매번 전송한 패킷에 대해 확인 응답을 받아야만 다음 패킷 전송
    - 모든 데이터를 이렇게 전송하려면 굉장히 많은 시간이 필요해짐
- Sliding Window
    - 수신측에서 설정한 윈도우 크기만큼만 확인 응답 없이 전송 가능
    - 윈도우에 포함되는 모든 패킷을 전송하고, 전달완료가 확인되는대로 윈도우를 옆으로 옮긴다는 의미에서 Sliding인 것!
    - TCP는 데이터에 유실이 발생하는 순간 윈도우 크기를 절반으로 줄이고 정상적인 통신이 되는 경우 서서히 하나씩 늘림

## 혼잡제어

: `네트워크 내의 패킷 수가 과도하게 증가`하는 현상을 방지하기 위한 기법
→ 흐름제어보다 더 넓은 관점

- AIMD(Additive Increase / Multiplicative Decrease)
    - 처음에는 1개의 패킷만 전송, 문제가 없을시 윈도우 크기를 1씩 늘려가며 전송
    - 혼잡현상이 발생하는 경우 윈도우 크기를 절반으로 줄인다.
    - 윈도우 크기가 매우 조금씩 증가함으로써 초기에는 높은 대역폭을 사용할 수 없기 때문에 시간이 오래걸린다.
- Slow Start ( 느린 시작 )
    - AIMD와 똑같이 처음에는 1개의 패킷만 전송하지만, 문제가 없을시 윈도우 크기를 2배로 늘려 전송
    - 혼잡현상이 발생하는 경우 윈도우 크기를 1로 줄인다.
    - 대역폭이 지수함수 꼴로 증가하기 때문에 AIMD의 초기 전송속도가 낮음을 보완
    - 한번 혼잡이 발생하고나면 네트워크 수용량 예측 가능
- Fast Retransmit (빠른 재전송)
    - 먼저 도착해야할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK 패킷 전송
    - 이때, 도착한 패킷을 기준으로 ACK 패킷이 전송되므로 중간에 손실된 패킷이 있음을 송신측에서 알 수 있다!
    - 중복 ACK를 3개 받으면 재전송이 이루어진다.
    - 송신측에서 자체적으로 설정한 타임아웃이 지나지 않더라도 해당 패킷을 빠르게 재전송 할 수 있다.
- Fast Recovery (빠른 회복)
    - 혼잡현상이 발행하는 경우 1이 아닌 절반으로 줄여 선형증가
    - 한번 혼잡현상이 발생한 뒤 부터는 AIMD 방식으로 동작

## UDP
- 4계층(전송계층)에서 이용되며, 가장 큰 특징은 비연결형으로써 신뢰성은 없지만 신속하게 데이터를 전송한다는 것이다!
- 주로 실시간 방송, 온라인 게임 등에서 사용된다.
- DNS에서도 주로 사용하는데, request 양이 작고 손실은 application 계층에서 제어가 가능하기 때문이다. 하지만 크기가 큰 경우 등에서는 TCP를 사용하기도 한다!

## 예상질문

- 흐름제어와 혼잡제어의 차이는 무엇일까요?
