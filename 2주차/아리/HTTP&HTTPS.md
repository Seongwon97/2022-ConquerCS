# HTTP & HTTPS

## HTTP

- 인터넷상에서 클라이언트와 서버가 자원을 주고받을 때 쓰는 통신 규약
- 도청, 위장, 변조 등이 가능하다는 보안 관련 위험성 존재

## HTTPS

- HTTP의 보안 관련 위험성을 해결하기 위하여 HTTP의 통신 소켓 부분을 SSL 혹은 TLS 프로토콜로 대체한 통신 규약
- HTTP의 경우 HTTP와 TCP가 직접 통신하지만, HTTPS의 경우 HTTP - SSL - TCP 로 통신
- 공통키를 공개키암호화 기법을 이용하여 공유하고, 추후 통신에 대해서는 공통키 암호화 기법을 활용하는 하이브리드 암호화 기법 이용!

## TLS/SSL HandShake

: HTTPS에서 통신 전 신뢰성 여부를 판단 및 공통키를 공유하기 위하여 이용하는 방식

< 통신을 준비하는 서버 >

1. 서버는 공개키/개인키 를 생성한다.
2. 해당 공개키의 신뢰성을 확보하기 위하여 인증기관(CA)에게 제출한다.
3. CA는 기업 이름, 공개키, 공개키 암호화 방법을 담은 인증서를 CA의 비밀키로 암호화하여 발급한다.

< 공개키를 받는 클라이언트 >

4. ( Client hello ) 처음으로 해당 서버와 통신하는 클라이언트는 클라이언트가 제공하는 SSL 버전, 암호 알고리즘, 압축 방식등을 담아 서버에 전송한다.
5. ( Server hello ) 서버는 인증기관에서 발급받은 인증서를 클라이언트에게 전송한다.
6. 클라이언트는 서버가 보낸 인증서가 신뢰할 수 있는 인증기관이 발급한 것인지 확인하기 위해 브라우저가 보유하고 있는 인증기관 목록을 확인한다.
7. 신뢰할 수 있는 인증기관이라면 브라우저에 저장된 인증기관의 공개키를 이용하여 해당 인증서를 해독하고, 이를 통해 서버의 공개키를 알게된다.

< 공개키와 난수를 이용하여 공통키 생성 >

8. 클라이언트는 난수를 생성한다. 이것이 서버와 클라이언트가 사용할 공통키가 된다!
9. 클라이언트는 handshake 과정이 완료되었다는 의미의 finish메시지와 함께 해당 난수를 공개키로 암호화하여 서버에게 전송한다. 이때 만약 5번에서 서버가 클라이언트 인증서를 요구했다면 인증서도 함께
   전송한다.
10. 서버는 개인키를 통해 난수를 추출함으로써 공통키를 획득했다!
11. 서버가 handshake 과정이 완료되었다는 의미의 finish메시지를 보내 통신할 준비가 되었음을 알리며 SSL HandShake가 종료된다.

## SSL의 단점

암호화/복호화 등을 위해 리소스를 다량으로 소비하기 때문에 느리다
→ 이를 위해 SSL을 처리하기 위한 전용 하드웨어인 SSL 엑셀레이터를 이용하기도 한다.

## 예상질문

- 모든 HTTPS 통신은 안전하다고 말할 수 있을까요?
- 서버가 발급한 공개키가 안전함을 보장하려면 어떻게 해야할까요?
