# Blocking / Non-Blocking  &  Synchronous / Non-Synchronous

## blocking vs non-blocking 
: 호출되는 함수의 `return 여부`로 `제어권이` 누구에게 있느냐가 관건!

< blocking >

- 요청한 작업을 마칠때까지 대기한 뒤 return한다.
- 자신의 작업을 모두 마칠때까지 제어권을 넘겨주지 않는 것!

< non-blocking >

- 요청한 작업을 마치지 않았어도 즉시 return한다.
- 호출한 함수에게 제어권을 넘겨주기 때문에 호출한 함수가 다른일을 할 수 있도록 함

## 동기(Synchronous) vs 비동기(Asynchronous)
: 호출되는 함수의 작업 `완료여부`를 `누가 신경쓰느냐`가 관건!

! 함수 A가 함수 B호출하는 경우

< 동기 >

- A는 B의 작업이 완료될 때 까지 다른 일을 하지 않고 대기한다.
- 호출한 A가 작업 완료를 신경쓰는 것!

< 비동기 >

- A는 B를 호출한 뒤 다른일을 처리한다.
- 호출된 함수 B가 ( callback 함수가 ) 작업 완료를 신경쓰는 것!

## 동기/비동기 & blocking/non-blocking 조합
- 동기 + blocking 
: 결과가 나올때까지 기다렸다가 return
- 동기 + non-blocking
: 바로 return하고 결과가 생길때까지 재시도
- 비동기 + blocking
: 결과 나올때까지 return 하지 않지만 호출함수는 신경쓰지 않음
<br/>→ 이점이 없어서 잘 사용하지 않는 방식!
<br/>→ 대표적인 예시가 node.js + MySQL : node.js가 비동기로 동작해도 MySQL에서 제공하는 드라이버가 Blocking방식이기 때문에 비동기의 이점을 누릴 수가 없다.
- 비동기 + non-blocking 
: 별도의 프로세서에서 작업진행하고 return, 끝나면 콜백함수 실행

## Blocking I/O
1. 프로세스(스레드)가 커널의 I/O 요청 함수 호출
2. 커널이 작업 완료하면 그때 결과 return

< 특징 >
- I/O 작업이 진행되는동안 프로세스(스레드)는 대기
- I/O 작업은 CPU 자원을 거의 쓰지 않기 때문에 자원 낭비가 심함
- 여러 클라이언트가 접속하는 서버라면? 하나의 클라이언트마다 스레드가 할당되기 때문에 스레드 수가 매우 많아짐으로써 컨텍스트 스위칭 비용이 증가한다.

## Non - Bloking I/O
1. 프로세스(스레드)가 커널의 I/O 요청 함수 호출
2. 커널은 작업 완료 여부와 관계없이 return 함으로써 제어권을 프로세스에게 넘겨줌
3. 프로세스는 제어권이 자신에게 넘어왔으므로 다른 작업 수행 가능
4. 다른 작업 수행 중간중간에 커널에게 작업완료여부 확인
