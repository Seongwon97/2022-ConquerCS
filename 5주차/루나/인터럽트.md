### **정의**

> 프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우 현재 실행 중인 작업을 즉시 중단하고, 발생된 상황에 대한 우선 처리가 필요함을 CPU에게 알리는 것
>
- 하드웨어 장치가 CPU에게 어떤 사실을 알려주거나 CPU의 서비스를 요청해야 할 경우, CPU 내에 있는 인터럽트 라인을 세팅하여 인터럽트를 발생시킨다. (프로그램이 명령을 수행하기 위해서는 CPU를 할당받아야 함)
- CPU는 매번 프로그램 카운터가 가리고 있는 곳의 명령을 수행한 뒤, 다음 명령을 수행하기 직전에 인터럽트 라인이 세팅되었는지 체크한다.
- 이를 통해 인터럽트가 발생했으면 CPU는 현재 수행 중이던 프로세스를 멈추고 운영 체제의 인터럽트 처리 루틴으로 이동하여 인터럽트 처리를 수행한다.

### 사용하는 이유

그 이유는 입출력 연산이 CPU 명령 수행속도보다 현저히 느리기 때문이다.

## 종류

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5269097f-19ec-4f95-8550-b8f4c05f03bd/Untitled.png)

### 하드웨어 인터럽트

- 하드웨어 컨트롤러가 **CPU의 서비스를 요청하기 위해 발생**시키는 인터럽트
- 입출력 장치, 타이밍 장치, 전원 등 외부적인 요인으로 발생
- ex) 전원 이상, 기계 착오, 외부 신호, 입출력

### 내부 인터럽트

CPU 코어 외부에서 인터럽트를 거는 경우가 일반적이지만, CPU 내부에서 실행하면서 인터럽트에 걸리는 경우

ex) 예외 상황(Exception)

- 프로그램이 허용되지 않은 연산을 수행하려고 할 때, 자동적으로 발생한다. 운영체제는 예외 상황이 발생했을 때, CPU의 제어권을 획득해 이 상황에 대한 조치를 취한다.
- ex) 0으로 나누는 연산, 자신의 주소 공간을 넘어서는 메모리 참조 등
- 예외 상황에 대한 처리 루틴을 자신의 코드 영역에 가지고 있음

### 소프트웨어 인터럽트(Trap)

- 소프트웨어가 발생시키는 인터럽트이다.
- 소프트웨어(사용자 프로그램)가 스스로 인터럽트 라인을 세팅한다. 즉, 명령어의 수행에 의해 발생된다.

ex) 시스템 콜(System Call)

- 사용자 프로세스가 운영체제의 서비스를 요청하기 위해 커널의 함수를 호출하는 것이다.
- 사용자 프로세스가 직접 특권 명령을 수행할 수 없으므로 특권 명령을 수행하려 할 때, 시스템 콜을 사용한다.

## **인터럽트 발생 처리 과정**

`요청` → `중단` → `보관` → `처리` → `재개`

![https://mblogthumb-phinf.pstatic.net/20160310_124/scw0531_14575366291105WjS7_PNG/ERTRTETRE.png?type=w2](https://mblogthumb-phinf.pstatic.net/20160310_124/scw0531_14575366291105WjS7_PNG/ERTRTETRE.png?type=w2)

1. 인터럽트 요청
2. 프로그램 실행 중단
    - 현재 실행중이던 **`Micro Operation`** 까지 수행
3. 현재 실행중인 프로그램 상태 보관
    - **`Interrupt Vector`** 를 읽어 **`ISR`**(인터럽트 서비스 루틴) 주소값을 얻음
        - ISR : 인터럽트 핸들러라고도 불리며, 인터럽트 접수에 의해 발생되는 인터럽트에 대해 특정 기능을 처리하는 기계어 코드 루틴이다.
    - ISR 로 점프 (이 때, PC 값은 자동 대피 저장됨)
    - 현재 진행중인 프로그램의 레지스터를 대피함
    - 잠시 저장하는 이유는, 인터럽트 서비스 루틴이 끝난 뒤 다시 원래 작업으로 돌아와야 하기 때문
4. 인터럽트 서비스 루틴 처리
    - 인터럽트 원인을 파악하고 실질적인 작업 수행
    - 서비스 루틴 수행 중, 우선순위가 더 높은 인터럽트가 발생하면 재귀적으로 1~5 과정 수행
5. 상태 복구
    - 해당 작업을 다 처리하면, 대피시킨 레지스터를 복원한다
    - ISR 끝에 **`RETI`** 명령어에 의해 인터럽트 해제
    - 명령어가 실행되면, PC 값을 복원하여 이전 실행 위치로 복원

### 인터럽트 핸들러

`CPU` 에서 인터럽트가 접수되면, 해당 `인터럽트 핸들러` 의 코드의 위치를 찾고 실행에 옮긴다. 실행 중이던 `레지스터` 와 `PC` 를 보관함으로써 CPU의 상태를 보존한다. 인터럽트가 핸들링이 완료되면 이전의 상태로 복귀된다.

### **인터럽트 벡터 (Interrupt Vector)**

인터럽트 요청이 발생했을 때, CPU는 인터럽트 소스가 무엇이며, 해당 인터럽트 ISR이 어디에 적재되어있는지를 확인해야한다. 이 때, CPU는 `인터럽트 벡터` 를 활용한다.

- 여러 종류의 인터럽트에 대한 ISR의 시작 주소
- `인터럽트 벡터 테이블` : 주기억장치의 특정 영역에 여러 개의 인터럽트에 대한 인터럽트 벡터를 모아놓은 영역

### **PC (Program Counter)**

CPU 내부에 있는 레지스터 중의 하나로서, 다음에 실행될 명령어의 주소를 가지고 있어 실행할 기계어 코드의 위치를 지정한다. 때문에 명령어 포인터라고도 불린다.

### **사용자 프로그램이 I/O 를 하는 과정**

- Mode bit
    - **`유저 모드(1)`** : 사용자 프로그램 수행
    - **`커널 모드(0)`** : OS 코드 수행
- 처리 과정
    1. SVC - 사용자 프로그램은 운영체제에게 I/O 요청
    2. Trap 을 사용하여 인터럽트 벡터의 특정 위치로 이동
    3. 제어권이 인터럽트 벡터가 가리키는 ISR 로 이동
    4. 올바른 I/O 인치 확인 후, 실행
    5. I/O 완료 시, 제어권을 SVC 다음 명령으로 이동
- 인터럽트와 트랩의 차이점
    - 인터럽트는 하드웨어적인 흐름의 변화이고, 트랩은 소프트웨어적이라 할 수 있다.
    - 인터럽트는 프로그램 외부 상황에 따라서 발생 시점이 일정하지 않기 때문에 `비동기적` 이다. 반면에 트랩은 발생 시점이 프로그램의 일정한 지점이라는 점에서 `동기적` 이다.

### 인터럽트 우선순위 판별 방법

- 폴링 (Polling)
    - 가장 높은 인터럽트로 부터 요청 플래그를 검사하여 ISR 을 수행하는 소프트웨어적인 방법 이다.
    - 인터럽트를 조사하는 비용이 들어 반응시간이 느리지만, 하드웨어를 추가할 필요가 없어 회로가 간단하다는 장점을 지니고 있다.
- 인터럽트 방식
    - MCU 자체가 하드웨적으로 변화를 체크하여 변화 시에만 일정한 동작을 하는 방식
    - 인터럽트 방식은 하드웨어로 지원을 받아야 하는 제약이 있지만, 폴링에 비해 신속하게 대응하는 것이 가능하다. 따라서 **실시간 대응**이 필요할 때는 필수적인 기능이다.
    - 즉, 인터럽트는 **발생시기를 예측하기 힘든 경우에 컨트롤러가 가장 빠르게 대응할 수 있는 방법**이다.
    - 예시
        - 데이지 체인 (Daisy Chain)
            - 어디에 인터럽트가 발생하는지 확인하는 회로를 직렬로 연결하는 하드웨어적인 방법 이다
        - 병렬 우선순위 부여