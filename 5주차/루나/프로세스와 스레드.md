## 프로세스

메모리상에서 실행되고 있는 프로그램

![https://camo.githubusercontent.com/3dc4ad61f03160c310a855a4bd68a9f2a2c9a4c7/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f393938383931343635433637433330363036](https://camo.githubusercontent.com/3dc4ad61f03160c310a855a4bd68a9f2a2c9a4c7/68747470733a2f2f74312e6461756d63646e2e6e65742f6366696c652f746973746f72792f393938383931343635433637433330363036)

### 프로그램

- 보조 기억장치(하드디스크, SSD)에 존재하며 본인이 실행되기를 기다리는 명령어(코드) 및 데이터들의 묶음
- 프로그램 자체는 동작을 하지 않는 정적이며 수동적인 개체여서, 프로그램을 실행시키려면 운영체제로부터 프로그램이 동작하는데 필요한 CPU, 메모리, 입출력장치, 파일 등의 자원을 할당받아 동작을 시작해야 한다.

### 프로세스

- 동작을 실행하게 된 프로그램.
- 메모리상에서 실행되고 있음.
- 기본적으로 프로세스마다 최소 한개의 스레드를 소유하고 있다.

### 프로그램이 프로세스가 되는 과정에서 일어나는 일

1. 운영체제는 프로세스가 필요로 하는 재료들을 메모리의 code, data, heap, stack 영역에 올려준다.
2. 또한 프로세스의 정보를 담은 PCB블럭(Process Control Block)이 메모리에 올라간다.

### 프로세스 메모리 공간

![141093433-8a3b798b-8ef8-49b8-8445-dc73d9dc20f6.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e3824424-46dc-4a25-8b9e-1d51af235a0d/141093433-8a3b798b-8ef8-49b8-8445-dc73d9dc20f6.png)

프로세스는 각각 별도의 주소공간을 독립적으로 할당한다.

- **Code(Text)** : CPU에서 수행되는 명령어를 저장
    - 코드 자체를 구성하는 메모리 영역(프로그램 명령)
    - Hex 파일이나 Bin 파일을 저장
- **Data** : 전역변수, 정적변수, 배열 등
    - 초기화 된 데이터는 data 영역에 저장
    - 초기화 되지 않은 데이터는 bss(Block Stated Symbol) 영역에 저장
- **Heap** : 동적 할당 시 사용 (new(), malloc() 등)
- **Stack** : 지역변수, 매개변수, 리턴 값 (임시 메모리 영역)
    - 함수 호출 시 생성이 되고, 함수가 끝나면 반환 된다.
    - Stack 사이즈는 각 프로세스마다 할당되지만, 프로세스가 메모리에 로드될 때 Stack 사이즈가 고정되어 있어 런타임시에 Stack 사이즈르 바꿀 순 없다.

**이렇게 구역을 나눈 이유**

- 최대한 데이터를 공유하여 메모리 사용향을 줄이기 위해서
    - Code는 같은 프로그램 자체에서는 모두 같은 내용이기 때문에 따로 관리하여 공유한다.
    - Stack과 data를 나눈 이유는, 스택 구조의 특성과 전역 변수의 활용성을 위한 것이다.

### **PCB 블록**

![https://user-images.githubusercontent.com/48278519/141098492-cd01efa9-6f1a-4327-b5d4-05391a54ced6.png](https://user-images.githubusercontent.com/48278519/141098492-cd01efa9-6f1a-4327-b5d4-05391a54ced6.png)

운영체제가 프로세스에 대한 중요한 정보를 저장해 놓는 곳으로 Task Control Block 또는 Job Control Block이라고 한다.

각 프로세스가 생성될 때마다 고유의 PCB가 생성되며 프로세스가 완료되면 PCB는 제거되며, PCB블럭은 메모리 중에서도 커널 스택과 같이 보호받을 수 있는 메모리에 저장된다.

- **PID** : 프로세스를 구분할 수 있는 고유의 번호
- **프로세스 상태(Process State)** : 준비 / 대기 /실행 등 프로세스의 상태를 나타내는 정보
- **PC(Program Counter)** : CPU가 다음으로 실행할 명령어를 가리키는 값
- **레지스터** : Accumulator, Index Register, 범용 레지스터, PC등에 대한 정보
- **CPU 스케줄링 정보** : 우선 순위, 최종 실행시각, CPU 점유시간 등에 대한 정보
- **포인터** : 부모프로세스에 대한 포인터, 자식 프로세스에 대한 포인터, 프로세스가 위치한 메모리 주소에 대한 포인터, 할당된 자원에 대한 포인터 정보 등
- **프로세스 계정 정보** : 페이지 테이블, 스케줄링 큐 포인터, 소유자, 부모..

### **특징**

- 프로세스는 각각 **독립된 메모리 영역(Code, Data, Stack, Heap의 구조)을 할당 받는다는 것**이 큰 특징이다.
- 각 프로세스는 **별도의 주소 공간**에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다.
- 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC, inter-process communication)을 사용해야 한다.

## 스레드

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/631c18d9-fc16-45a9-bdd9-3ac62c1869da/Untitled.png)

- 프로세스 내에서 실행되는 여러 흐름의 단위
- 하나의 프로세스가 생성될 때, 기본적으로 하나의 스레드는 같이 생성된다.
- 스레드는 프로세스 내에서 레지스터와 **Stack만 따로 할당**받고 Code, Data, Heap 영역은 스레드끼리 공유한다.

### 프로세스와 스레드의 차이

- 프로세스는 운영체제로부터 자원을 할당받는 작업의 단위이지만 스레드는 할당받은 자원을 이용하는 실행의 단위이다.
- 프로세스는 자신만의 고유 공간과 자원을 할당받아 사용하는데 반해, 스레드는 다른 스레드와 공간 자원을 공유하면서 사용한다.
- 하나의 프로세스 내에 1개 이상의 스레드를 가질 수 있다.

## 멀티 시리즈에 대해 알아보자

### **멀티프로세스**

> 하나의 컴퓨터에 여러 CPU → 하나 이상의 프로세스들을 동시에 처리(병렬)
>

부모 프로세스가 fork()하여 자식 프로세스를 생성하면 자식프로세스는 독립적인 메모리 영역을 가지면서 하나의 프로그램을 처리할 수 있다.

![141113570-4fd9319b-380f-4bab-b6e0-f412a9306ba1.jpg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c889f19c-c104-4b48-a2c5-55439815a3d5/141113570-4fd9319b-380f-4bab-b6e0-f412a9306ba1.jpg)

**장점**

- 안전성 (메모리 침범 문제를 OS 차원에서 해결)
- 각 프로세스가 독립된 메모리 영역 (Code, Data, Heap, Stack)을 가지고 있기 때문에 , 여러 자식 프로세스 중 하나에 문제가 발생하여도 해당 프로세스에만 영향을 미침

**단점**

- 각각 독립된 메모리 영역을 갖고 있어, 작업량 많을 수록 오버헤드 발생.
- 프로세스 간의 복잡한 통신 (IPC) 가 필요함
- Context Switching으로 인한 성능 저하
    - ***Context Switching :*** 프로세스의 상태 정보를 저장하고 복원하는 일련의 과정
        - 즉, 동작 중인 프로세스가 대기하면서 해당 프로세스의 상태를 보관하고, 대기하고 있던 다음 순번의 프로세스가 동작하면서 이전에 보관했던 프로세스 상태를 복구하는 과정을 말함

      → 프로세스는 각 독립된 메모리 영역을 할당받아 사용되므로, 캐시 메모리 초기화와 같은 무거운 작업이 진행되었을 때 오버헤드가 발생할 문제가 존재함


### **멀티 스레드**

> 하나의 응용 프로그램에서 여러 스레드를 구성해 각 스레드가 하나의 작업을 처리하는 것
>

![141113627-b9166460-412f-41a1-9cf4-75f684222915.jpg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/69a0e426-9020-4a0b-bf6b-88b93472f60b/141113627-b9166460-412f-41a1-9cf4-75f684222915.jpg)

스레드들이 공유 메모리를 통해 다수의 작업을 동시에 처리하도록 해줌

**장점**

- 독립적인 프로세스에 비해 공유 메모리만큼의 시간, 자원 손실이 감소
- 전역 변수와 정적 변수에 대한 자료 공유 가능
- Context switching시 비용이 적음 (교환해야 할 대상이 적으므로))
- Data, Heap 영역을 이용해 데이터를 주고 받으므로 스레드간 통신이 간단함

**단점**

- 서로 다른 스레드가 Stack을 제외한 메모리 공간을 공유하기 때문에 동기화 문제가 발생할 수 있음
- 스레드 간의 자원 공유는 전역 변수(데이터 세그먼트)를 이용하므로 다른 스레드가 동시에 사용할 때 충돌이 발생할 수 있음
- 하나의 스레드가 데이터 공간 망가뜨리면, 모든 스레드가 작동 불능 상태 (공유 메모리를 갖기 때문)
- 하나의 스레드에 문제가 생기면 전체 프로세스가 영향을 받음
- 디버깅이 까다로움

⇒ 멀티스레드의 안전성에 대한 단점은 Critical Section 기법을 통해 대비함

- Critical Section은 (임계구역 또는 공유변수 영역) 병렬프로그래밍에서 둘 이상의 스레드 (멀티스레드)가 동시에 접근해서는 안되는 공유 자원(파일, 입출력, 공유 데이터 등) 을 접근하는 명령문 또는 코드의 일부 영역을 말한다.
- 하나의 스레드가 공유 데이터 값을 변경하는 시점에 다른 스레드가 그 값을 읽으려할 때 발생하는 문제를 해결하기 위한 동기화 과정
- 충족해야 하는 조건
    - **상호 배제 (mutual exclusion)**
      하나의 프로세스가 임계 구역에서 실행되고 있다면, 다른 프로세스들은 임계 구역에서 실행될 수 없다.
    - **진행 (progress)**
      임계 구역에 실행되고 있는 프로세스가 없을 경우, 들어갈 프로세스를 적절히 선택해야 한다.
    - **한정된 대기 (bounded waiting)**
      프로세스의 기아를 방지하기 위해, 한번 임계 구역에서 실행된 프로세스는 다음 실행에 대한 제한을 두어야한다.

### **멀티 프로세싱**

- 두개 이상의 CPU가 협력적으로 하나 이상의 작업(Task)을 동시에 처리하는 것 (병렬성)
- register와 cache를 독립적으로 가진 여러개의 CPU가 1개의 메모리에 연결된 구조

### **멀티 코어**

- CPU 칩 내부에 register와 cache를 갖고 있는 core 만 따로 회로를 구성한 구조고, 해당 코어가 2개 이상이면서 동시에 한 개 이상의 작업을 처리하는 것