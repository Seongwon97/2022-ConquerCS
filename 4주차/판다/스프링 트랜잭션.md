## 트랜잭션 동기화
- 여러 개의 작업을 하나의 트랜잭션으로 관리하려면 Connection 객체를 공유해야 한다.
- 스프링은 Connection 객체를 스프링이 관리하는 별도의 저장소에 보관해두고 필요할 때 꺼내쓰도록 한다.
- 쓰레드마다 Connection 객체가 별도로 관리된다. 
- Hibernate와 같은 ORM 사용 시, Connection이 아닌 Session 객체를 통해 트랜잭션을 구현. 
- ORM 기술에 종속적인 문제를 해결하기 위해 트랜잭션 관리 부분을 추상화


## 트랜잭션 추상화
- 스프링은 트랜잭션 기술의 공통점을 담은 `PlatformTransactionManager` 인터페이스를 통해 트랜잭션 처리에 대한 추상화를 제공
- ORM 기술에 종속적인 코드 없이 트랜잭션을 처리 가능

## AOP를 통한 트랜잭션 분리
- 비즈니스 로직과 트랜잭션 처리 로직을 분리하기 위해 `@Transactional` 어노테이션을 지원한다. 

## 스프링 트랜잭션의 세부 설정
- 트랜잭션 전파 수준 : 트랜잭션이 진행중에 있을 때, 새로운 작업이 시작된 경우 해당 작업에 대한 트랜잭션의 처리를 결정
  -> 기존 트랜잭션에 병합, 독립적인 트랜잭션 생성, 트랜잭션 없이 동작,... etc.
  
- 격리 수준 : 격리 수준 설정. 
  -> 기본적으로는 Default를 따르는 것이 좋지만, 특수한 기능을 수행하는 메소드면 직접 격리 수준을 설정
  
- 제한시간 : 트랜잭션을 수행하는 제한시간 설정
  - 별도 설정이 없으면 default값을 따른다
  - 제한시간 내에 완료 못하면 예외 발생
  - 제한시간 관련 설정을 지원하지 않는 경우 에러가 날 수도. 
  - 기존 트랜잭션에 병합되는 경우 의미 없는 설정
  
- 읽기전용 : readOnly 설정이 된 트랜잭션이 시작된 이후 Insert, Update, Delete 작업이 진행되면 예외 발생

- 롤백/커밋 예외 : 스프링은 기본적으로 checked 예외는 롤백을 하지 않고, unchecked 예외(RuntimeException)이나 에러가 발생하면 롤백을 한다. 
  -> 별개의 처리를 원하면 `rollbackFor` 또는 `noRollback` 속성을 지정해야 한다. 

## Fallback Policy
- 모든 메소드에 어노테이션을 붙이면 지저분해진다.
- 메소드 -> 클래스 -> 선언 메소드 -> 선언 클래스/인터페이스 순서로 @Transactional 이 적용되었는지 확인. 


## 권장 사용법
- 특정 계층의 경계를 트랜잭션 경계와 일치시킨다 -> 주로 서비스 레이어
- 테스트를 제외하고는 다른 도메인에서 직접 DAO에 접근하는 것은 차단해야 한다 -> 서비스 계층에 위임 메소드를 만들어 놓을 것

- 클래스 레벨에 readOnly를 적용하고, Insert, Update, Delete 작업이 진행되는 개별 메소드에 @Transactional 어노테이션을 붙일 것 -> 약간의 성능 상 이점 존재

- 테스트에 어노테이션을 붙이면 테스트의 DB 커밋을 롤백. 
- auto_increment나 sequence 등에 의해 증가된 값은 롤백이 되지 않으므로 주의



