## 트랜잭션

: 하나의 작업을 수행하기 위해 필요한 데이터베이스의 연산들을 모아놓은 작업 단위

- 데이터베이스에서 **논리적인 작업의 단위**이며 장애가 발생했을 때 **데이터를 복구하는 작업의 단위**이다.
- 트랜잭션을 관리함으로써 데이터베이스의 회복과 병행 제어가 가능해져 데이터의 정합성을 보장해준다.

## 트랜잭션 특징(ACID)

### 원자성(Atomicity)

- 트랜잭션을 구성하는 연산들이 모두 정상적으로 실행되거나 하나도 실행되지 않아야 한다는 `all-or-nothing` 방식을 의미한다.
- 이처럼 트랜잭션의 원자성을 보장하려면 장애가 발생했을 때 데이터베이스의 원래 상태로 복구하는 회복 기능이 필요하다.

### 일관성(Consistency)

- 트랜잭션이 성공적으로 완료되면 데이터베이스는 일관적인 상태를 유지해야 함을 의미한다.
- 쉽게 말하자면, 트랜잭션이 제약조건, `cascade` , `triggers` 를 포함한 정의된 모든 조건에 맞게 데이터의 값이 변경되야 함을 뜻한다.

### 독립성(Isolation)

- 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다.

### 지속성(Durability)

- 트랜잭션이 성공적으로 완료되었으면, 결과는 영구적으로 반영되어야 한다.

## 트랜잭션의 연산

데이터베이스에 날린 쿼리가 반영되는 시점은 트랜잭션이 성공적으로 완료되는 시점에 반영이 되는데, 트랜잭션에는 두 가지 과정이 있다.

### **Commit**

- 트랜잭션이 성공적으로 수행되었을 때 선언한다(작업 완료).
- `commit` 연산이 실행된 후에야 트랜잭션의 수행 결과가 데이터베이스에 반영된다.

### **Rollback**

- 트랜잭션이 수행을 실패했을 때 선언한다(작업 취소).
    - 비정상적으로 종료되어 트랜잭션 원자성이 깨졌다고 볼 수 있다.
- `rollback` 연산이 실행되면 트랜잭션이 지금까지 실행한 연산의 결과를 취소하고 수행 전의 상태로 돌아간다.

## 트랜잭션의 상태

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a1900f7a-2652-492a-b904-4723f89092cb/Untitled.png)

- 활동(Active) : 트랜잭션이 실행중인 상태
- 부분 완료(Parially Committed) : 트랜잭션의 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태
- 완료(Commit) : 트랜잭션이 성공적으로 종료되어 `commit` 연산을 실행한 후의 상태
- 실패(Failed) : 트랜잭션 실행에 오류가 발생해 중단된 상태
- 철회(Aborted) : 트랜잭션이 비정상적으로 종료되어 `rollback` 연산을 수행한 상태

## **Transaction 관리를 위한 DBMS의 전략**

[관련 네이버 D2 링크](https://d2.naver.com/helloworld/407507)

이해를 위한 2가지 개념 : DBMS의 구조 / Buffer 관리 정책

### DBMS의 구조

DBMS는 크게 크게 질의 처리기(Query Processor)와 저장 시스템(Storage System)으로 나눠볼 수 있다.

- 저장 시스템: 보통 비휘발성 저장 장치인 디스크에 데이터를 저장하며 전체 데이터베이스의 일부분을 메인 메모리에 유지
    - 입출력 단위: 고정 길이의 페이지로 disk에 읽거나 쓴다.
    - 페이지 버퍼 관리자(버퍼 관리자) : 메인메모리에 유지하는 페이지를 관리하는 모듈
        - Buffer 관리 정책에 따라, UNDO 복구와 REDO 복구가 요구되거나 그렇지 않게 되므로, transaction 관리에 매우 중요한 결정을 가져온다.

![https://d2.naver.com/content/images/2015/06/helloworld-407507-1.png](https://d2.naver.com/content/images/2015/06/helloworld-407507-1.png)

### 버퍼 관리 정책

1. **UNDO**

> 어떠한 이유로든 정상적으로 종료될 수 없게 된 트랜잭션이 변경한 페이지를 이전 상태로 되돌리는 것.
>

만약 버퍼 관리자가 트랜잭션 종료 전에는 어떤 경우에도 수정된 페이지들을 디스크에 쓰지 않는다면, UNDO 오퍼레이션은 메모리 버퍼에 대해서만 이루어지면 되는 식으로 매우 간단해질 수 있다. 하지만, 매우 큰 크기의 메모리 버퍼가 필요함.

- 이를 해결하기 위한 2개의 정책 (수정된 페이지를 디스크에 쓰는 시점으로 분류)
    1. steal : 수정된 페이지를 언제든지 디스크에 쓸 수 있는 정책
        - 대부분의 DBMS가 채택하는 Buffer 관리 정책
        - UNDO logging과 복구를 필요로 함.
    2. ¬steal : 수정된 페이지들을 EOT (End Of Transaction)까지는 버퍼에 유지하는 정책
        - UNDO 작업이 필요하지 않지만, 매우 큰 메모리 버퍼가 필요함.
1. **REDO**

> 이미 commit한 transaction의 수정을 재반영하는 복구 작업
>

정책의 종류 : Transaction이 종료되는 시점에 해당 transaction이 수정한 page를 디스크에 쓸 것인가 아닌가로 기준.

1. FORCE : 수정했던 모든 페이지를 Transaction commit 시점에 disk에 반영
    - 1transaction이 commit 되었을 때 수정된 페이지들이 disk 상에 반영되므로 redo 필요 없음.
2. ¬FORCE : commit 시점에 반영하지 않는 정책
    - transaction이 disk 상의 db에 반영되지 않을 수 있기에 redo 복구가 필요. (대부분의 DBMS 정책)

⇒ 이런 복구를 위해 가장 많이 쓰이는 구조는 로그이며, 자세한 내용은 생략