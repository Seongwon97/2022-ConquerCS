# Transaction

> 하나의 논리적 기능을 수행하기 위한 작업의 단위



References

- [[DB기초] 트랜잭션이란 무엇인가? (tistory.com)](https://coding-factory.tistory.com/226)
- [DBMS는 어떻게 트랜잭션을 관리할까? (naver.com)](https://d2.naver.com/helloworld/407507)
- [[DB/ Oracle] REDO와 UNDO 동작 과정을 이해해보자 (tistory.com)](https://loosie.tistory.com/527)



## 특징

### Atomicity(원자성)

다 반영되거나, 다 반영되지 않거나

- ex) Line을 추가했으면 Section까지 추가되어야, Section을 추가하지 못했으면 Line도 추가되지 못해야 함

### Consistency(일관성)

트랜잭션을 성공적으로 완료한 후에는 일관성 있는 DB 상태 (시스템의 고정적인 요소들이 변하지 않아야)

### Isolation(독립성)

둘 이상의 트랜잭션이 병행 실행될 시 하나의 트랜잭션 사이에 다른 트랜잭션의 연산이 끼어들 수 없음, 한 트랜잭션이 완전히 완료될 때까지는 다른 트랜잭션에서 해당 연산의 수행 결과를 참조할 수 없음

### Durability(영속성, 지속성)

성공적으로 완료된 트랜잭션의 결과는 영구적으로 반영되어야

---



## Transcation 연산

### COMMIT

한 트랜잭션이 성공적으로 끝났고, DB의 상태가 일관된 상태로 돌아왔으며 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산

### ROLLBACK

트랜잭션이 비정상 종료되어 DB 일관성을 깨뜨렸을 때, 일부 연산이 정상 처리 되었더라도 원자성 구현을 위해 해당 트랜잭션이 수행한 연산을 모두 취소(UNDO)시키는 연산 (해당 트랜잭션을 재시작 또는 폐기)

---



## DBMS의 Transcation 관리 전략

- UNDO: 현재 상태에서 과거 시점으로 돌아가기 위함(rollback)
  - 필요한 정보: 어떻게 하면 과거의 상태로 돌아갈 수 있는지
- REDO: 과거 시점에서 최근의 상태로 돌아가기 위함(roll-forward)
  - 필요한 정보: 어떤 동작들이 일어났는지



### UNDO와 STEAL

수정 내역을 관리하는 정책들

- STEAL: 수정 사항을 언제든지 디스크에 쓸 수 있는 정책
  - 버퍼 메모리 자주 비워짐 → 버퍼 메모리 작아도 됨
  - 이미 반영된 상태에서 트랜잭션이 실패하면 UNDO 필요
- • ¬STEAL: 수정 사항을 트랜잭션이 종료 되기 전까지는 디스크에 쓸 수 없는 ㅓㅇ
  - 트랜잭션 잘 끝났을 때만 반영하므로 UNDO 따로 필요 없음
  - 버퍼 메모리에 차곡차곡 다 쌓아놓아야 하기 때문에 버퍼 메모리가 많이 필요함

### REDO와 FORCE

수정 내역을 디스크에 반영하는 정책들

- FORCE: 모든 수정 내역을 트랜잭션 commit과 함께 디스크에 반영
  - 이미 최신 상태를 가지고 있기 떄문에 REDO 필요 X
- ¬FORCE: 트랜잭션이 commit되는 시점에도 디스크에 반영되지 않음
  - commit한 내용이 제대로 반영되지 않을지도()

> 대부분의 DBMS는 STEAL + ¬FORCE → UNDO, REDO 모두 포함




